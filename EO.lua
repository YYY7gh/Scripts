local sltl = {
	{HRWT = " ", ERJG = "'"},
	{HRWT = "\n", ERJG = '"'},
	{HRWT = "", ERJG = "\\"},

	{HRWT = "a", ERJG = "q"},
	{HRWT = "b", ERJG = "z"},
	{HRWT = "c", ERJG = "j"},
	{HRWT = "d", ERJG = "m"},
	{HRWT = "e", ERJG = "p"},
	{HRWT = "f", ERJG = "k"},
	{HRWT = "g", ERJG = "x"},
	{HRWT = "h", ERJG = "l"},
	{HRWT = "i", ERJG = "t"},
	{HRWT = "j", ERJG = "a"},
	{HRWT = "k", ERJG = "o"},
	{HRWT = "l", ERJG = "v"},
	{HRWT = "m", ERJG = "c"},
	{HRWT = "n", ERJG = "y"},
	{HRWT = "o", ERJG = "f"},
	{HRWT = "p", ERJG = "r"},
	{HRWT = "q", ERJG = "s"},
	{HRWT = "r", ERJG = "h"},
	{HRWT = "s", ERJG = "d"},
	{HRWT = "t", ERJG = "n"},
	{HRWT = "u", ERJG = "e"},
	{HRWT = "v", ERJG = "w"},
	{HRWT = "w", ERJG = "i"},
	{HRWT = "x", ERJG = "g"},
	{HRWT = "y", ERJG = "u"},
	{HRWT = "z", ERJG = "b"},

	{HRWT = "A", ERJG = "Q"},
	{HRWT = "B", ERJG = "Z"},
	{HRWT = "C", ERJG = "J"},
	{HRWT = "D", ERJG = "M"},
	{HRWT = "E", ERJG = "P"},
	{HRWT = "F", ERJG = "K"},
	{HRWT = "G", ERJG = "X"},
	{HRWT = "H", ERJG = "L"},
	{HRWT = "I", ERJG = "T"},
	{HRWT = "J", ERJG = "A"},
	{HRWT = "K", ERJG = "O"},
	{HRWT = "L", ERJG = "V"},
	{HRWT = "M", ERJG = "C"},
	{HRWT = "N", ERJG = "Y"},
	{HRWT = "O", ERJG = "F"},
	{HRWT = "P", ERJG = "R"},
	{HRWT = "Q", ERJG = "S"},
	{HRWT = "R", ERJG = "H"},
	{HRWT = "S", ERJG = "D"},
	{HRWT = "T", ERJG = "N"},
	{HRWT = "U", ERJG = "E"},
	{HRWT = "V", ERJG = "W"},
	{HRWT = "W", ERJG = "I"},
	{HRWT = "X", ERJG = "G"},
	{HRWT = "Y", ERJG = "U"},
	{HRWT = "Z", ERJG = "B"},

	{HRWT = "0", ERJG = "5"},
	{HRWT = "1", ERJG = "8"},
	{HRWT = "2", ERJG = "3"},
	{HRWT = "3", ERJG = "7"},
	{HRWT = "4", ERJG = "9"},
	{HRWT = "5", ERJG = "1"},
	{HRWT = "6", ERJG = "0"},
	{HRWT = "7", ERJG = "2"},
	{HRWT = "8", ERJG = "4"},
	{HRWT = "9", ERJG = "6"},

	{HRWT = "\%", ERJG = ","},
	{HRWT = "(", ERJG = "}"},
	{HRWT = "%)", ERJG = "%["},
	{HRWT = "%[", ERJG = "%]"},
	{HRWT = "{", ERJG = ";"},
	{HRWT = "}", ERJG = ":"},
	{HRWT = ":", ERJG = "."},
	{HRWT = "<", ERJG = "?"},
	{HRWT = ">", ERJG = "@"},
	{HRWT = "!", ERJG = "_"},
	{HRWT = "=", ERJG = "!"},
	{HRWT = "_", ERJG = "="},
	{HRWT = "\\", ERJG = "*"},
	{HRWT = ".", ERJG = "^"},
	{HRWT = ",", ERJG = ">"},
	{HRWT = "'", ERJG = "$"},
	{HRWT = '"', ERJG = "&"},
	{HRWT = "-", ERJG = "+"},
	{HRWT = "+", ERJG = "-"}
}
local Keys = {"eegeazfvr","eefzdrbhhf","rtyjgtggh","dtyjhbtyhd","tdyjhdbny","qwefasdgh","zxccvbnmn","ytrewvads","plmnokjuy","asdfghjkl","qwertyuiop","zxcvbnmasd","qazwsxdrc","ujmnhbgvf","ikjuhygtf","rtyujhgbn","bnmjhktyu","vfrdesxyz","plmnoijqp","edcvbnmlo","qwertyuiq","uiooiuytr","wsxdrtghf","qwertyadf","asdfghjyt","plmnbvcxz","qazwsxxcv","eertyuioo","mnbvcxzawq","trewqabcd","fjdkghfhj","ryujgfddd","ertyuiohi","qwepoiuyt","asdfgghhj","znmllkjuy","plmnfgtyu","xcvbnmjem","qwegbzhha","dstgrdtyt","bvcxzwerq","qwljkigfv","efrtghdfg","vgbnhyihg","retyhbnjh","plmoijyux","sdgejklas","qxczvisjr","wertyuvbn","abcdexzty","aqwyhihyi","plenjkjvy","mkfjghjdesc","sxdcghzaz","uyhntxytf","oipyulrty","gfdsersty","qwxdrtyzw","dfgfhjkkx","lkjhfghst","wykv.lkoq","fvbnfyksf","jwefuwgwe","gvcnxayts","zrdfntghp","qwerftvbn","rtghfwigj","xytqewrdf","lplkaaaab","uytrwffds","vbnmklstd","yhuuawads","abfdhique","edfhuiqwe","poiufdghj","qwertplio","asdqaznym","frickybye","nifllmllk","yuhncvbnj","mjklbiope","dyhtxzscx","uwyntjezr","riunmkoej","bghjzanyj","nhyghxtdr","zcdfbnmaj","rtyhgxdgh","yhnluifew","vbgngtrdf","lqyvirnrb","twyerwtf","fghtpohgt","oykmjaert","nmvcxzoiu","abchjlkms","qwegydfag","mikukliuu","fgasdhuhh","eingvlmas"}
local lookupValueToCharacter = buffer.create(64)
local lookupCharacterToValue = buffer.create(256)

local alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
local BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"

local padding = string.byte("=")

for index = 1, 64 do
	local value = index - 1
	local character = string.byte(alphabet, index)

	buffer.writeu8(lookupValueToCharacter, value, character)
	buffer.writeu8(lookupCharacterToValue, character, value)
end


function atbashEncode(input)
	local output = {}
	for i = 1, #input do
		local char = input:sub(i, i)
		if char:match("%a") then
			local isUpper = string.byte(char) >= string.byte('A') and string.byte(char) <= string.byte('Z')
			local base = isUpper and string.byte('A') or string.byte('a')
			local newChar = string.char(base + (25 - (string.byte(char) - base)))
			table.insert(output, newChar)
		else
			table.insert(output, char)
		end
	end
	return table.concat(output)
end
local function base64Encode(input)
	input = buffer.fromstring(input)
	local inputLength = buffer.len(input)
	local inputChunks = math.ceil(inputLength / 3)

	local outputLength = inputChunks * 4
	local output = buffer.create(outputLength)

	for chunkIndex = 1, inputChunks - 1 do
		local inputIndex = (chunkIndex - 1) * 3
		local outputIndex = (chunkIndex - 1) * 4

		local chunk = bit32.byteswap(buffer.readu32(input, inputIndex))

		local value1 = bit32.rshift(chunk, 26)
		local value2 = bit32.band(bit32.rshift(chunk, 20), 0b111111)
		local value3 = bit32.band(bit32.rshift(chunk, 14), 0b111111)
		local value4 = bit32.band(bit32.rshift(chunk, 8), 0b111111)

		buffer.writeu8(output, outputIndex, buffer.readu8(lookupValueToCharacter, value1))
		buffer.writeu8(output, outputIndex + 1, buffer.readu8(lookupValueToCharacter, value2))
		buffer.writeu8(output, outputIndex + 2, buffer.readu8(lookupValueToCharacter, value3))
		buffer.writeu8(output, outputIndex + 3, buffer.readu8(lookupValueToCharacter, value4))
	end

	local inputRemainder = inputLength % 3

	if inputRemainder == 1 then
		local chunk = buffer.readu8(input, inputLength - 1)

		local value1 = bit32.rshift(chunk, 2)
		local value2 = bit32.band(bit32.lshift(chunk, 4), 0b111111)

		buffer.writeu8(output, outputLength - 4, buffer.readu8(lookupValueToCharacter, value1))
		buffer.writeu8(output, outputLength - 3, buffer.readu8(lookupValueToCharacter, value2))
		buffer.writeu8(output, outputLength - 2, padding)
		buffer.writeu8(output, outputLength - 1, padding)
	elseif inputRemainder == 2 then
		local chunk = bit32.bor(
			bit32.lshift(buffer.readu8(input, inputLength - 2), 8),
			buffer.readu8(input, inputLength - 1)
		)

		local value1 = bit32.rshift(chunk, 10)
		local value2 = bit32.band(bit32.rshift(chunk, 4), 0b111111)
		local value3 = bit32.band(bit32.lshift(chunk, 2), 0b111111)

		buffer.writeu8(output, outputLength - 4, buffer.readu8(lookupValueToCharacter, value1))
		buffer.writeu8(output, outputLength - 3, buffer.readu8(lookupValueToCharacter, value2))
		buffer.writeu8(output, outputLength - 2, buffer.readu8(lookupValueToCharacter, value3))
		buffer.writeu8(output, outputLength - 1, padding)
	elseif inputRemainder == 0 and inputLength ~= 0 then
		local chunk = bit32.bor(
			bit32.lshift(buffer.readu8(input, inputLength - 3), 16),
			bit32.lshift(buffer.readu8(input, inputLength - 2), 8),
			buffer.readu8(input, inputLength - 1)
		)

		local value1 = bit32.rshift(chunk, 18)
		local value2 = bit32.band(bit32.rshift(chunk, 12), 0b111111)
		local value3 = bit32.band(bit32.rshift(chunk, 6), 0b111111)
		local value4 = bit32.band(chunk, 0b111111)

		buffer.writeu8(output, outputLength - 4, buffer.readu8(lookupValueToCharacter, value1))
		buffer.writeu8(output, outputLength - 3, buffer.readu8(lookupValueToCharacter, value2))
		buffer.writeu8(output, outputLength - 2, buffer.readu8(lookupValueToCharacter, value3))
		buffer.writeu8(output, outputLength - 1, buffer.readu8(lookupValueToCharacter, value4))
	end

	return buffer.tostring(output)
end


local function base64Decode(input)
	input = buffer.fromstring(input)
	local inputLength = buffer.len(input)
	local inputChunks = math.ceil(inputLength / 4)

	local inputPadding = 0
	if inputLength ~= 0 then
		if buffer.readu8(input, inputLength - 1) == padding then inputPadding += 1 end
		if buffer.readu8(input, inputLength - 2) == padding then inputPadding += 1 end
	end

	local outputLength = inputChunks * 3 - inputPadding
	local output = buffer.create(outputLength)

	for chunkIndex = 1, inputChunks - 1 do
		local inputIndex = (chunkIndex - 1) * 4
		local outputIndex = (chunkIndex - 1) * 3

		local value1 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, inputIndex))
		local value2 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, inputIndex + 1))
		local value3 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, inputIndex + 2))
		local value4 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, inputIndex + 3))

		local chunk = bit32.bor(
			bit32.lshift(value1, 18),
			bit32.lshift(value2, 12),
			bit32.lshift(value3, 6),
			value4
		)

		local character1 = bit32.rshift(chunk, 16)
		local character2 = bit32.band(bit32.rshift(chunk, 8), 0b11111111)
		local character3 = bit32.band(chunk, 0b11111111)

		buffer.writeu8(output, outputIndex, character1)
		buffer.writeu8(output, outputIndex + 1, character2)
		buffer.writeu8(output, outputIndex + 2, character3)
	end

	if inputLength ~= 0 then
		local lastInputIndex = (inputChunks - 1) * 4
		local lastOutputIndex = (inputChunks - 1) * 3

		local lastValue1 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, lastInputIndex))
		local lastValue2 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, lastInputIndex + 1))
		local lastValue3 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, lastInputIndex + 2))
		local lastValue4 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, lastInputIndex + 3))

		local lastChunk = bit32.bor(
			bit32.lshift(lastValue1, 18),
			bit32.lshift(lastValue2, 12),
			bit32.lshift(lastValue3, 6),
			lastValue4
		)

		if inputPadding <= 2 then
			local lastCharacter1 = bit32.rshift(lastChunk, 16)
			buffer.writeu8(output, lastOutputIndex, lastCharacter1)

			if inputPadding <= 1 then
				local lastCharacter2 = bit32.band(bit32.rshift(lastChunk, 8), 0b11111111)
				buffer.writeu8(output, lastOutputIndex + 1, lastCharacter2)

				if inputPadding == 0 then
					local lastCharacter3 = bit32.band(lastChunk, 0b11111111)
					buffer.writeu8(output, lastOutputIndex + 2, lastCharacter3)
				end
			end
		end
	end

	return buffer.tostring(output)
end
function Base16encode(data)
	local output = ""
	for i = 1, #data do
		output = output .. string.format("%02X", data:byte(i))
	end
	return output
end

function Base16decode(hex)
	local output = ""

	for i = 1, #hex, 2 do
		local byte = hex:sub(i, i + 1)
		output = output .. string.char(tonumber(byte, 16))
	end

	return output
end

function caesarEncode(input, shift)
	local encoded = {}
	for i = 1, #input do
		local char = input:sub(i, i)
		local ascii = string.byte(char)


		local newAscii = ascii + shift


		if newAscii > 126 then
			newAscii = newAscii - 95
		end

		local newChar = string.char(newAscii)
		table.insert(encoded, newChar)
	end
	return table.concat(encoded)
end

function caesarDecode(input, shift)
	local decoded = {}
	for i = 1, #input do
		local char = input:sub(i, i)
		local ascii = string.byte(char)

		local newAscii = ascii - shift

		if newAscii < 32 then
			newAscii = newAscii + 95
		end

		local newChar = string.char(newAscii)
		table.insert(decoded, newChar)
	end
	return table.concat(decoded)
end
local function xorEncrypt(text, key)
	local result = {}
	for i = 1, #text do
		local char = text:sub(i, i)
		local keyChar = key:sub((i - 1) % #key + 1, (i - 1) % #key + 1)
		result[i] = string.char(bit32.bxor(string.byte(char), string.byte(keyChar)))
	end
	return table.concat(result)
end

local function xorDecrypt(encryptedText, key)
	return xorEncrypt(encryptedText, key)
end
function enc(str)
	return (str:gsub('.', function (c)
		return string.format('%02X', string.byte(c))
	end))
end
function dec(str)
	return (str:gsub('..', function (cc)
		local num = tonumber(cc, 16) 
		if not num then 
			error("Stop skidding!")
		end
		return string.char(num) 
	end))
end
local function urlEncode(input)
	return (input:gsub(
		"([^%w%.%- ])",
		function(c)
			return string.format("%%%02X", string.byte(c))
		end
		):gsub(" ", "+"))
end

local function urlDecode(input)
	return (input:gsub("+", " "):gsub("%%(%x%x)", function(h)
		return string.char(tonumber(h, 16))
	end))
end
function rot13(input)
	local output = {}
	for i = 1, #input do
		local char = input:sub(i, i)
		local ascii = string.byte(char)
		if (ascii >= 65 and ascii <= 90) then
			ascii = ((ascii - 65 + 13) % 26) + 65
		elseif (ascii >= 97 and ascii <= 122) then
			ascii = ((ascii - 97 + 13) % 26) + 97
		end
		table.insert(output, string.char(ascii))
	end
	return table.concat(output)
end
function encode(input, key)
	local random = math.random(0,99)
	local Key = Keys[random+1]
	Key = rot13(Key)
	Key = enc(Key)
	Key = base64Encode(Key)
	Key = Base16encode(Key)
	Key = string.reverse(Key)
	input = urlEncode(input)
	input = rot13(input)
	input = string.reverse(input)
	input = enc(input)
	input = caesarEncode(input, random)
	input = base64Encode(input)
	input = Base16encode(input)
	input = enc(input)
	input = xorEncrypt(input, key)
	return(string.reverse(tostring(Key).."//"..tostring(input)))
end
local key = "~RW{QPxRSzT_}[U"
function decode(input, key)
	input = string.reverse(input)
	local split = string.split(input, "//")
	local shift = split[1]
	shift = string.reverse(shift)
	shift = Base16decode(shift)
	shift = base64Decode(shift)
	shift = dec(shift)
	shift = rot13(shift)
	for i,v in pairs(Keys) do
		if v == shift then
			shift = i-1
		end
	end
	input = split[2]
	input = xorDecrypt(input, key)
	input = dec(input)
	input = Base16decode(input)
	input = base64Decode(input)
	input = caesarDecode(input, shift)
	input = dec(input)
	input = string.reverse(input)
	input = rot13(input)
	input = urlDecode(input)
	return(input)
end

function DecWC(input)
	local char = {}
	for i = 1, #input do
		local currentChar = input:sub(i, i)
		local found = false
		for _, v in pairs(sltl) do
			if tostring(currentChar) == tostring(v.ERJG) then
				char[i] = v.HRWT
				found = true
				break
			end
		end
		if not found then
			char[i] = currentChar
		end
	end
	local output = table.concat(char)
	return output
end
function EncWC(input)
	local char = {}
	for i = 1, #input do
		local currentChar = input:sub(i, i)
		local found = false
		for _, v in pairs(sltl) do
			if tostring(currentChar) == tostring(v.HRWT) then
				char[i] = v.ERJG
				found = true
				break
			end
		end
		if not found then
			char[i] = currentChar
		end
	end
	local output = table.concat(char)
	return output
end
local function trim(s)
	return s:match("^%s*(.-)%s*$")
end
function EEEncode(key, input)
	key = "~RW{QPxRSzT_}[U"
	input = "Key."..key.."]]]"..input
	local char = {}
	for i = 1, #input do
		local currentChar = input:sub(i, i)
		local found = false
		for _, v in pairs(sltl) do
			if tostring(currentChar) == tostring(v.HRWT) then
				char[i] = v.ERJG
				found = true
				break
			end
		end
		if not found then
			char[i] = currentChar
		end
	end
	local output = encode(table.concat(char), key)
	return(trim(output))
end
function DDDecode(key, input)
	key = "~RW{QPxRSzT_}[U"
	local isPastThrough = false
	input = decode(input, key)
	local split = string.split(input, "]]]")
	if tostring(DecWC(split[1])) == "Key."..key then isPastThrough = true end
	if isPastThrough then
		local function getStr(index)
			local value = ""
			for i,v in pairs(split) do
				if i >= tonumber(index) then
					value = value.." "..v
				end
			end
			local value = value:sub(2)
			return value
		end
		input = getStr(2)
		local char = {}
		for i = 1, #input do
			local currentChar = input:sub(i, i)
			local found = false
			for _, v in pairs(sltl) do
				if tostring(currentChar) == tostring(v.ERJG) then
					char[i] = v.HRWT
					found = true
					break
				end
			end
			if not found then
				char[i] = currentChar
			end
		end
		local output = table.concat(char)
		loadstring(trim(output))()
	else
		return("There was error decoding your string")
	end
end
DDDecode(key, _G.Script093)
